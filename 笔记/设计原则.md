# 设计原则

![image-20211230174342119](/Users/10023991/Library/Application Support/typora-user-images/image-20211230174342119.png)

### 1、单一职责

一个类或者模块只负责完成一个职责(或者功能).不要设计大而全的类,要设计粒度小、功能单一的类.

### 2、开闭原则

对扩展开放、对修改关闭.添加一个新的功能应该是,在已有代码基础上扩展代码(新增类、方法等),而非修改已有代码(类、方法等).

#### 如何做到对扩展开放、对修改关闭

1. 时刻具备扩展意识、抽象意识、封装意识,事先留好扩展点.
2. 利用多态、依赖注入、基于接口而非实现编程,以及设计模式来提升代码扩展性

### 3、里氏替换原则

子类对象能够替换程序中父类对象出现的任何地方,并保证原来程序的逻辑行为不变及正确性不被破坏.

#### 常见违背里氏替换原则的例子:

1. **子类违背父类声明要实现的功能**

​	父类提供的orderByAmount()函数,是按金额进行排序,而子类重写后按照创建时间来排序.那么这个子类的设计就是违背了里氏替换原则

2. **子类违背父类对输入、输出、异常的约定**

​	父类函数约定:运行出错时返回null;获取数据为空时返回空集合.但子类重载函数后,运行出错时直接抛出异常,获取不到数据返回null.此时子类的设计也是违背了里氏替换原则.

3. **子类违背父类注释中所罗列的任何特殊说明**

父类函数注释写的是:“用户提现金额不得超过账户余额...”,子类重写时,针对vip用户实现了透支提现的功能,这样子类的设计就是违反了里氏替换原则.

### 4、接口隔离原则

客户端(接口调用者)不应该强迫依赖他不需要的接口.

#### 4.1、这里的接口可以理解为:

- 一组API接口集合
- 单个API接口或函数
- OOP中的接口概念

##### 把接口理解为一组API接口集合

以下为微服务用户系统提供的一组跟用户相关相关的API给其它系统进行调用,包含注册、登录、获取用户信息等.

```java
public interface UserService {
  boolean register(String phone, String password);
  boolean login(String phone, String password);
  UserInfo getUserInfoById(String id);
  ...
}
```

现在,后台管理系统需要实现删除用户的功能,希望提供一个删除用户的接口.此时,若我们直接在UserService中定义删除接口,可以解决当前的需求问题,但也存在安全隐患.

本来删除用户的操作只想提供给后台管理系统进行使用,现在使用了UserService的系统都可以调用该API调用删除用户的接口,可能导致用户被误删.

以上就是我们将接口理解为一组接口集合,可以是微服务中的某个服务的接口,也可以是类库的接口.所以在微服务或者类库接口设计时,如果接口只被部分调用者使用,那我们就需要将这部分接口隔离出来,单独给对应的调用者使用,而不强迫其它调用者也依赖这部分不会被使用到的接口.

##### 把接口理解为单个API接口或函数

函数的设计要功能单一,不要将多个不同的功能逻辑放在同一个函数中实现.

如有一个count()函数,里面统计了最大值、最少值、平均值等各个维度的数据,若某些地方只需要获取最大值或者平均值等部分统计结果,那么该接口的设计就是违反了接口隔离原则.我们可以将count()逻辑进行拆分,拆分为max()、min()、avg()等函数

##### 把接口理解为OOP中的接口概念

相当于面向对象编程中的接口语法.接口的设计要尽量单一,不要让接口的实现类和调用者,依赖不需要的接口函数.

#### 4.2、接口隔离原则与单一职责原则的区别

单一职责原则针对的是模块、类、接口的设计.接口隔离原则更侧重接口的设计,思考的角度也不一样.判断接口是否满足接口单一原则主要从调用者使用接口来间接判断,如果调用者只使用了部分接口或者接口的部分功能,那么接口的设计就不够职责单一.

### 5、依赖反转原则

高层模块不要依赖低层模块,高层模块和低层模块应该通过抽象来相互依赖.除此之外,抽象不要依赖具体实现细节,具体实现依赖抽象.

#### 5.1、控制反转

控制反转一般用来指导框架层面的设计.**控制**指的是对程序执行流程的控制,**反转**指的是没有使用框架前,我们自己控制整个程序的执行.在使用框架后,整个程序的执行流程由框架来控制,流程的控制权从程序员自身反转成了框架.

#### 5.2、依赖注入

不通过new的方式在类内部创建依赖的对象,而是将依赖的类对象在外部创建好后,通过构造函数、函数参数等方式传递(或注入)给类使用.

#### 5.3、依赖注入框架

通过依赖注入框架提供的扩展点,简单配置下所需要的类及其类与类之间的依赖关系,就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要你程序员来做的事情.

### 6、KISS原则

尽量保持简单.这里的简单不是单纯的以代码行数来判断.代码函数越少并不意味着代码越简单,我们还要考虑逻辑复杂的、实现难度、代码可读性等.

##### 指导原则

- 不要使用同事可能不懂的技术来实现
- 不要重复造轮子,善于使用已有的工具类库
- 不要过度优化

### 7、YAGNI原则

不要过度设计.不要去设计当前用不到的功能,不要去编写当前用不到的代码.

### 8、DRY原则

Don’t  repeat yourself.不要写重复代码.

#### 8.1、违反DRY原则的情况

##### 实现逻辑重复

##### 功能语义重复

##### 代码执行重复

#### 8.2、提高代码可复用性的方法

- 减少代码耦合
- 满足单一职责原则
- 模块化
- 业务与非业务逻辑分离
- 通用代码下沉
- 继承、多态、抽象、封装
- 应用模版等设计模式

### 9、迪米特法则

高内聚、松耦合.不该有直接依赖关系的类之间,不要有依赖;有依赖关系的类之间,尽量只依赖必要的接口.迪米特法则希望减少类之间的耦合,让类越独立越好.每个类都应该少了解系统的其它部分.

#### 高内聚

用来指导类本身的设计.相近的功能应该放到同一个类中,不相近的功能不要放到一个类中.相近的功能往往会被同时修改,放到一个类中,修改比较集中,代码容易维护.

#### 松耦合

用来指导类与类之间依赖关系的设计.在代码中,类与类之间的依赖关系简单清晰.即使两个类有依赖关系,一个类的代码改动不会或者很少导致依赖类的代码改动.

